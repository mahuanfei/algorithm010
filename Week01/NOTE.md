学习笔记总结

/****************学习复杂度总结和发现问题的想法总结****************/

时间复杂度
效率排序 从高到低

O(1)
O(logn): 例如 :while或者for中执行循环次数为i = i/2 或者 i = i * 2, 其中不一定是常数 2,也可以为 3,或者 4 则执行次数为logn;
O(n): 比如简单打印操作 1层的for/while循环,复杂度跟n线性关系,n为多少执行多少次
O(n^2), 2层嵌套for/while循环 做打印操作
O(n^3), 3层for/while循环 做打印操作
O(2^n), 斐波那契
O(n!)
指数级涨的很快,复杂度效率差别天壤之别

二分查找O(logn): 一分为二只查一边时间复杂度为O(logn)
二叉树遍历O(n): 每次一分为二,但每次一分为二之后,每一边是相等的时间复杂度T(n) = 2T(n/2) + O(1),另一个维度思考每个节点只访问一次,所以是O(n)

一维有序数组二分查找 O(logn)
二维有序矩阵查找 O(n)
归并 O(nlogn)

前,中,后序 遍历O(n), n为节点总数,每个节点访问一次且仅访问一次,所以时间复杂度线性于节点总数

空间复杂度
1 代码中开了数组,数组长度是空间
2 递归的深度

爬楼梯问题
暴力
没有缓存情况下时间复杂度: 每一层一分为2依次为1, 2,4,8,… 所以为O(2^n)
空间复杂度:深度最大可能是n层,所以为O(n)

记忆递归
由于有了缓存所以不再重复计算相同的方法数,时间复杂度变成了O(n) 即每个台阶到n个台阶的方法数只被计算了一次
空间复杂度,因为开了数组O(n),同时递归的深度是n,两个是并行关系,所以整体空间复杂度为O(n)

动态规划
时间复杂度O(n),单循环到n,空间复杂度O(n),dp数组用了n空间

爬楼梯用斐波那契
用两个常数作为基点,保存开始的状态,
时间复杂度O(n),单循环到n,空间复杂度为O(1)

爬楼梯发现问题的总结
1 在用DP时要注意 int[] dp = new int[n + 1] 还是 int[] dp = new int[n + 2]
为什么有的时候用new int[n + 1]有的时候用new int[n + 2] ?
当有if (n == 1) return 1;的时候用 int[] dp = new int[n + 1]
当没有if ( n == 1) return 1;的时候用 int[] dp = new int[n+2];
当带入 n = 1 时,dp[2] 越界问题
为什么有了if(n == 1) return 1; 的时候还要用int[] dp = new int[n +1]呢?
因为程序中for的条件是i <= n,如果不为 n+1 那么dp[n]就越界了

2 在爬楼梯用斐波那契数解决问题的时候要忽略掉dp[0] (但从斐波那契角度,dp[0] = 1 只是借助于这个方法来得到dp[2]的结果为2而写的),实际上不存在爬0阶楼梯的,如果要说爬0阶楼梯只能说dp[0] = 0,有0个台阶不需要爬,没有方法数所以为0 注意如果dp[0] = 1; dp[1] = 1则for中的i是从2开始到n的. 如果是dp[1] = 1; dp[2] = 2,则for中的i是从3开始到n的.
3 在记忆化递归中返回mems[i]表示什么?
当n=4的时候mems数组为
/* [0: (1 + 2), 1: (2 + 3), 2: (3 + 4), 3: (4 + 5)]
[0: (3 + 2), 1: (2 + 1), 2: (1 + 1), 3: (1 + 0)] */

不懂的问题归并排序复杂度的计算问题不懂
归并 O(nlogn) 这里有个问题,归并也是一分为2,再每一边相等的时间复杂度,那么在归并的过程中为什么是logn 不是O(n)呢
                                                      
/****************学习复杂度总结和发现问题的想法总结****************/                                                               
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
 /****************学习栈和队列笔记****************/                                        
栈和队列
双端队列,栈和队列:添加,删除为O(1),查询为O(n),因为无序,所以查询某个都全部遍历一遍
Stack:先入后出push和pop
Queue:先入先出 remove() 与 poll() 抛不抛异常
Deque(两端可以进出的Queue):双端队列:queue和stack的结合体,就是一个队列,可以往两端添加删除 API addLast() pollLast()
Priority Queue   插入O(1),取出操作O(logN)  按照  元素的优先级取出
Priority的底层具体实现的数据结构较为多样和复杂heap(这里的堆不一定是二叉树堆,可能是Fibonacci堆),也可以是所谓的BST(binary search tree,二叉搜索树实现),也可以是平衡二叉树(比如红黑树,AVL实现)做的简单的可以数组实现只不过有些慢,也可以用一个实时进行动态排序,加一个元素sort下只是就是O(n)不是O(logn)
google查询用stack java version
google搜source stack java  或者java source code
vector和Arraylist的区别是vector是线程安全的

作业分析Queue和Priority Queue的 源码
实现后进先出官网不推荐用stack推荐用deque


为什么这个题目可以用栈解决,如果一个东西有最近相关性的话,用栈
现实生活中都有从外向内或者从内向外逐渐扩散,或者最外层和最外层是一对,最内层和和最内侧是一对,把这个叫做最近相关性就要用到栈这种数据结构了,所有的东西都是现实中有的我们进行了一个抽象.                                       

 /****************学习栈和队列笔记****************/ 